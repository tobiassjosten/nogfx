// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package pkg

import (
	"sync"
)

// Ensure, that UIMock does implement UI.
// If this is not the case, regenerate this file with moq.
var _ UI = &UIMock{}

// UIMock is a mock implementation of UI.
//
//      func TestSomethingThatUsesUI(t *testing.T) {
//
//              // make and configure a mocked UI
//              mockedUI := &UIMock{
//                      MaskInputFunc: func()  {
//                              panic("mock out the MaskInput method")
//                      },
//                      PrintFunc: func(bytes []byte)  {
//                              panic("mock out the Print method")
//                      },
//                      RunFunc: func(bytesCh <-chan []byte, valCh chan<- struct{})  {
//                              panic("mock out the Run method")
//                      },
//                      UnmaskInputFunc: func()  {
//                              panic("mock out the UnmaskInput method")
//                      },
//              }
//
//              // use mockedUI in code that requires UI
//              // and then make assertions.
//
//      }
type UIMock struct {
	// MaskInputFunc mocks the MaskInput method.
	MaskInputFunc func()

	// PrintFunc mocks the Print method.
	PrintFunc func(bytes []byte)

	// RunFunc mocks the Run method.
	RunFunc func(bytesCh <-chan []byte, valCh chan<- struct{})

	// UnmaskInputFunc mocks the UnmaskInput method.
	UnmaskInputFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// MaskInput holds details about calls to the MaskInput method.
		MaskInput []struct {
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// BytesCh is the bytesCh argument value.
			BytesCh <-chan []byte
			// ValCh is the valCh argument value.
			ValCh chan<- struct{}
		}
		// UnmaskInput holds details about calls to the UnmaskInput method.
		UnmaskInput []struct {
		}
	}
	lockMaskInput   sync.RWMutex
	lockPrint       sync.RWMutex
	lockRun         sync.RWMutex
	lockUnmaskInput sync.RWMutex
}

// MaskInput calls MaskInputFunc.
func (mock *UIMock) MaskInput() {
	if mock.MaskInputFunc == nil {
		panic("UIMock.MaskInputFunc: method is nil but UI.MaskInput was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMaskInput.Lock()
	mock.calls.MaskInput = append(mock.calls.MaskInput, callInfo)
	mock.lockMaskInput.Unlock()
	mock.MaskInputFunc()
}

// MaskInputCalls gets all the calls that were made to MaskInput.
// Check the length with:
//     len(mockedUI.MaskInputCalls())
func (mock *UIMock) MaskInputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMaskInput.RLock()
	calls = mock.calls.MaskInput
	mock.lockMaskInput.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *UIMock) Print(bytes []byte) {
	if mock.PrintFunc == nil {
		panic("UIMock.PrintFunc: method is nil but UI.Print was just called")
	}
	callInfo := struct {
		Bytes []byte
	}{
		Bytes: bytes,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(bytes)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//     len(mockedUI.PrintCalls())
func (mock *UIMock) PrintCalls() []struct {
	Bytes []byte
} {
	var calls []struct {
		Bytes []byte
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *UIMock) Run(bytesCh <-chan []byte, valCh chan<- struct{}) {
	if mock.RunFunc == nil {
		panic("UIMock.RunFunc: method is nil but UI.Run was just called")
	}
	callInfo := struct {
		BytesCh <-chan []byte
		ValCh   chan<- struct{}
	}{
		BytesCh: bytesCh,
		ValCh:   valCh,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	mock.RunFunc(bytesCh, valCh)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//     len(mockedUI.RunCalls())
func (mock *UIMock) RunCalls() []struct {
	BytesCh <-chan []byte
	ValCh   chan<- struct{}
} {
	var calls []struct {
		BytesCh <-chan []byte
		ValCh   chan<- struct{}
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// UnmaskInput calls UnmaskInputFunc.
func (mock *UIMock) UnmaskInput() {
	if mock.UnmaskInputFunc == nil {
		panic("UIMock.UnmaskInputFunc: method is nil but UI.UnmaskInput was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnmaskInput.Lock()
	mock.calls.UnmaskInput = append(mock.calls.UnmaskInput, callInfo)
	mock.lockUnmaskInput.Unlock()
	mock.UnmaskInputFunc()
}

// UnmaskInputCalls gets all the calls that were made to UnmaskInput.
// Check the length with:
//     len(mockedUI.UnmaskInputCalls())
func (mock *UIMock) UnmaskInputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnmaskInput.RLock()
	calls = mock.calls.UnmaskInput
	mock.lockUnmaskInput.RUnlock()
	return calls
}
