// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package pkg

import (
	"bufio"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
// 	func TestSomethingThatUsesClient(t *testing.T) {
//
// 		// make and configure a mocked Client
// 		mockedClient := &ClientMock{
// 			DoFunc: func(v byte) error {
// 				panic("mock out the Do method")
// 			},
// 			DontFunc: func(v byte) error {
// 				panic("mock out the Dont method")
// 			},
// 			ReadFunc: func(p []byte) (int, error) {
// 				panic("mock out the Read method")
// 			},
// 			ScannerFunc: func() *bufio.Scanner {
// 				panic("mock out the Scanner method")
// 			},
// 			SubnegFunc: func(v byte, bytes []byte) error {
// 				panic("mock out the Subneg method")
// 			},
// 			WillFunc: func(v byte) error {
// 				panic("mock out the Will method")
// 			},
// 			WontFunc: func(v byte) error {
// 				panic("mock out the Wont method")
// 			},
// 			WriteFunc: func(p []byte) (int, error) {
// 				panic("mock out the Write method")
// 			},
// 		}
//
// 		// use mockedClient in code that requires Client
// 		// and then make assertions.
//
// 	}
type ClientMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(v byte) error

	// DontFunc mocks the Dont method.
	DontFunc func(v byte) error

	// ReadFunc mocks the Read method.
	ReadFunc func(p []byte) (int, error)

	// ScannerFunc mocks the Scanner method.
	ScannerFunc func() *bufio.Scanner

	// SubnegFunc mocks the Subneg method.
	SubnegFunc func(v byte, bytes []byte) error

	// WillFunc mocks the Will method.
	WillFunc func(v byte) error

	// WontFunc mocks the Wont method.
	WontFunc func(v byte) error

	// WriteFunc mocks the Write method.
	WriteFunc func(p []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// V is the v argument value.
			V byte
		}
		// Dont holds details about calls to the Dont method.
		Dont []struct {
			// V is the v argument value.
			V byte
		}
		// Read holds details about calls to the Read method.
		Read []struct {
			// P is the p argument value.
			P []byte
		}
		// Scanner holds details about calls to the Scanner method.
		Scanner []struct {
		}
		// Subneg holds details about calls to the Subneg method.
		Subneg []struct {
			// V is the v argument value.
			V byte
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// Will holds details about calls to the Will method.
		Will []struct {
			// V is the v argument value.
			V byte
		}
		// Wont holds details about calls to the Wont method.
		Wont []struct {
			// V is the v argument value.
			V byte
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// P is the p argument value.
			P []byte
		}
	}
	lockDo      sync.RWMutex
	lockDont    sync.RWMutex
	lockRead    sync.RWMutex
	lockScanner sync.RWMutex
	lockSubneg  sync.RWMutex
	lockWill    sync.RWMutex
	lockWont    sync.RWMutex
	lockWrite   sync.RWMutex
}

// Do calls DoFunc.
func (mock *ClientMock) Do(v byte) error {
	if mock.DoFunc == nil {
		panic("ClientMock.DoFunc: method is nil but Client.Do was just called")
	}
	callInfo := struct {
		V byte
	}{
		V: v,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(v)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedClient.DoCalls())
func (mock *ClientMock) DoCalls() []struct {
	V byte
} {
	var calls []struct {
		V byte
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Dont calls DontFunc.
func (mock *ClientMock) Dont(v byte) error {
	if mock.DontFunc == nil {
		panic("ClientMock.DontFunc: method is nil but Client.Dont was just called")
	}
	callInfo := struct {
		V byte
	}{
		V: v,
	}
	mock.lockDont.Lock()
	mock.calls.Dont = append(mock.calls.Dont, callInfo)
	mock.lockDont.Unlock()
	return mock.DontFunc(v)
}

// DontCalls gets all the calls that were made to Dont.
// Check the length with:
//     len(mockedClient.DontCalls())
func (mock *ClientMock) DontCalls() []struct {
	V byte
} {
	var calls []struct {
		V byte
	}
	mock.lockDont.RLock()
	calls = mock.calls.Dont
	mock.lockDont.RUnlock()
	return calls
}

// Read calls ReadFunc.
func (mock *ClientMock) Read(p []byte) (int, error) {
	if mock.ReadFunc == nil {
		panic("ClientMock.ReadFunc: method is nil but Client.Read was just called")
	}
	callInfo := struct {
		P []byte
	}{
		P: p,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(p)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//     len(mockedClient.ReadCalls())
func (mock *ClientMock) ReadCalls() []struct {
	P []byte
} {
	var calls []struct {
		P []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// Scanner calls ScannerFunc.
func (mock *ClientMock) Scanner() *bufio.Scanner {
	if mock.ScannerFunc == nil {
		panic("ClientMock.ScannerFunc: method is nil but Client.Scanner was just called")
	}
	callInfo := struct {
	}{}
	mock.lockScanner.Lock()
	mock.calls.Scanner = append(mock.calls.Scanner, callInfo)
	mock.lockScanner.Unlock()
	return mock.ScannerFunc()
}

// ScannerCalls gets all the calls that were made to Scanner.
// Check the length with:
//     len(mockedClient.ScannerCalls())
func (mock *ClientMock) ScannerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockScanner.RLock()
	calls = mock.calls.Scanner
	mock.lockScanner.RUnlock()
	return calls
}

// Subneg calls SubnegFunc.
func (mock *ClientMock) Subneg(v byte, bytes []byte) error {
	if mock.SubnegFunc == nil {
		panic("ClientMock.SubnegFunc: method is nil but Client.Subneg was just called")
	}
	callInfo := struct {
		V     byte
		Bytes []byte
	}{
		V:     v,
		Bytes: bytes,
	}
	mock.lockSubneg.Lock()
	mock.calls.Subneg = append(mock.calls.Subneg, callInfo)
	mock.lockSubneg.Unlock()
	return mock.SubnegFunc(v, bytes)
}

// SubnegCalls gets all the calls that were made to Subneg.
// Check the length with:
//     len(mockedClient.SubnegCalls())
func (mock *ClientMock) SubnegCalls() []struct {
	V     byte
	Bytes []byte
} {
	var calls []struct {
		V     byte
		Bytes []byte
	}
	mock.lockSubneg.RLock()
	calls = mock.calls.Subneg
	mock.lockSubneg.RUnlock()
	return calls
}

// Will calls WillFunc.
func (mock *ClientMock) Will(v byte) error {
	if mock.WillFunc == nil {
		panic("ClientMock.WillFunc: method is nil but Client.Will was just called")
	}
	callInfo := struct {
		V byte
	}{
		V: v,
	}
	mock.lockWill.Lock()
	mock.calls.Will = append(mock.calls.Will, callInfo)
	mock.lockWill.Unlock()
	return mock.WillFunc(v)
}

// WillCalls gets all the calls that were made to Will.
// Check the length with:
//     len(mockedClient.WillCalls())
func (mock *ClientMock) WillCalls() []struct {
	V byte
} {
	var calls []struct {
		V byte
	}
	mock.lockWill.RLock()
	calls = mock.calls.Will
	mock.lockWill.RUnlock()
	return calls
}

// Wont calls WontFunc.
func (mock *ClientMock) Wont(v byte) error {
	if mock.WontFunc == nil {
		panic("ClientMock.WontFunc: method is nil but Client.Wont was just called")
	}
	callInfo := struct {
		V byte
	}{
		V: v,
	}
	mock.lockWont.Lock()
	mock.calls.Wont = append(mock.calls.Wont, callInfo)
	mock.lockWont.Unlock()
	return mock.WontFunc(v)
}

// WontCalls gets all the calls that were made to Wont.
// Check the length with:
//     len(mockedClient.WontCalls())
func (mock *ClientMock) WontCalls() []struct {
	V byte
} {
	var calls []struct {
		V byte
	}
	mock.lockWont.RLock()
	calls = mock.calls.Wont
	mock.lockWont.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *ClientMock) Write(p []byte) (int, error) {
	if mock.WriteFunc == nil {
		panic("ClientMock.WriteFunc: method is nil but Client.Write was just called")
	}
	callInfo := struct {
		P []byte
	}{
		P: p,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(p)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//     len(mockedClient.WriteCalls())
func (mock *ClientMock) WriteCalls() []struct {
	P []byte
} {
	var calls []struct {
		P []byte
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}
